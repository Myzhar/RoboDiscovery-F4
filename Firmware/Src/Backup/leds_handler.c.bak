#include "leds_handler.h"
#include "tim.h"

// >>>>> Values to update the color of the leds
// @Note: at each interrupt the values in upd_led_X_vals vectors are
//        decreased. If the value is zero the led is off.
//        Each update cycle lasts 256 counts, for 256 levels of light of each led

static uint8_t led_upd_count;

static uint8_t led_R_vals[MAX_LED_COUNT]; // Contains the R value for each led
static uint8_t led_G_vals[MAX_LED_COUNT]; // Contains the G value for each led
static uint8_t led_B_vals[MAX_LED_COUNT]; // Contains the B value for each led

static uint8_t upd_led_R_vals[MAX_LED_COUNT]; // Contains the status of each R led. If not zero the led is ON
static uint8_t upd_led_G_vals[MAX_LED_COUNT]; // Contains the status of each G led. If not zero the led is ON
static uint8_t upd_led_B_vals[MAX_LED_COUNT]; // Contains the status of each B led. If not zero the led is ON
// <<<<< Values to update the color of the leds 

#define TR_S1_R GPIO_PIN_0
#define TR_S1_G GPIO_PIN_1
#define TR_S1_B GPIO_PIN_2
#define TR_S2_R GPIO_PIN_3
#define TR_S2_G GPIO_PIN_4
#define TR_S2_B GPIO_PIN_5

#define KLED_1 GPIO_PIN_6
#define KLED_2 GPIO_PIN_7
#define KLED_3 GPIO_PIN_8
#define KLED_4 GPIO_PIN_9
#define KLED_5 GPIO_PIN_10
#define KLED_6 GPIO_PIN_11
#define KLED_7 GPIO_PIN_12
#define KLED_8 GPIO_PIN_13

void initRgbLeds( void )
{
	resetRgbLeds();
	
	for( uint8_t i=0; i<MAX_LED_COUNT; i++  )
	{
		upd_led_R_vals[i]=0;
		upd_led_G_vals[i]=0;
		upd_led_B_vals[i]=0;			
	}
	
	HAL_TIM_Base_Start_IT( &htim7 );
}

inline void resetRgbLeds(void)
{	
	// All the leds (included the 4 on Discovery Board) are on PORTD
	HAL_GPIO_WritePin( GPIOD, KLED_1, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_2, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_3, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_4, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_5, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_6, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_7, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, KLED_8, GPIO_PIN_RESET );
	HAL_GPIO_WritePin( GPIOD, TR_S1_R, GPIO_PIN_SET );
	HAL_GPIO_WritePin( GPIOD, TR_S1_G, GPIO_PIN_SET );
	HAL_GPIO_WritePin( GPIOD, TR_S1_B, GPIO_PIN_SET );
	HAL_GPIO_WritePin( GPIOD, TR_S2_R, GPIO_PIN_SET );
	HAL_GPIO_WritePin( GPIOD, TR_S2_G, GPIO_PIN_SET );
	HAL_GPIO_WritePin( GPIOD, TR_S2_B, GPIO_PIN_SET );
}

void setLedDiscRed( uint8_t state )
{
	if( state==LED_ON ) 
		HAL_GPIO_WritePin( GPIOD, GPIO_PIN_14, GPIO_PIN_RESET );
	else
		HAL_GPIO_WritePin( GPIOD, GPIO_PIN_14, GPIO_PIN_SET );
}

void toggleLedDiscRed( void )
{
	GPIOD->ODR ^= GPIO_PIN_14;
}

void setLedDiscBlue( uint8_t state )
{
	if( state==LED_ON ) 
		HAL_GPIO_WritePin( GPIOD, GPIO_PIN_15, GPIO_PIN_RESET );
	else
		HAL_GPIO_WritePin( GPIOD, GPIO_PIN_15, GPIO_PIN_SET );
}

void toggleLedDiscBlue( void )
{
	GPIOD->ODR ^= GPIO_PIN_15;
}

void setStateLedColor( uint8_t ledIdx, uint8_t color )
{
	if( ledIdx>15 )
		return;
	
	switch(color)
	{
		case LED_RED:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_R, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_R, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_GREEN:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_G, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_G, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_BLUE:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_B, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_B, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_YELLOW:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_R, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_G, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_R, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_G, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_PURPLE:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_R, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_B, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_R, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_B, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_CYAN:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_G, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_B, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_G, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_B, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_WHITE:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_R, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_G, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_B, GPIO_PIN_RESET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_R, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_G, GPIO_PIN_RESET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_B, GPIO_PIN_RESET );
			}					
		}
		break;
		
		case LED_BLACK:
		{
			if( ledIdx%2 == 0 )
			{
				HAL_GPIO_WritePin( GPIOD, TR_S1_R, GPIO_PIN_SET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_G, GPIO_PIN_SET );
				HAL_GPIO_WritePin( GPIOD, TR_S1_B, GPIO_PIN_SET );
			}
			else
			{
				HAL_GPIO_WritePin( GPIOD, TR_S2_R, GPIO_PIN_SET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_G, GPIO_PIN_SET );
				HAL_GPIO_WritePin( GPIOD, TR_S2_B, GPIO_PIN_SET );
			}					
		}
		break;
	}
	
	uint8_t pin = ledIdx/2;
	uint16_t pinK_idx;
	if( pin==0 )
		pinK_idx = KLED_1;
	else if( pin==1 )
		pinK_idx = KLED_2;
	else if( pin==2 )
		pinK_idx = KLED_3;
	else if( pin==3 )
		pinK_idx = KLED_4;
	else if( pin==4 )
		pinK_idx = KLED_5;
	else if( pin==5 )
		pinK_idx = KLED_6;
	else if( pin==6 )
		pinK_idx = KLED_7;
	else if( pin==7 )
		pinK_idx = KLED_8;
	
	HAL_GPIO_WritePin( GPIOD, pinK_idx, GPIO_PIN_SET );	
}

void on_RGB_led_timer_timeout( void )
{
	// >>>>> Update RGB values if this is the first update of the cycle
	if( led_upd_count==0 )
	{
		for( uint8_t i=0; i<MAX_LED_COUNT; i++  )
		{
			upd_led_R_vals[i]=led_R_vals[i];
			upd_led_G_vals[i]=led_G_vals[i];
			upd_led_B_vals[i]=led_B_vals[i];
		}
	}
	// <<<<< Update RGB values if this is the first update of the cycle
	
	// >>>>> Decrease RGB update values
	for( uint8_t i=0; i<MAX_LED_COUNT; i++  )
	{
		if(upd_led_R_vals[i]!=0)
			upd_led_R_vals[i]--;
		
		if(upd_led_G_vals[i]!=0)
			upd_led_G_vals[i]--;
		
		if(upd_led_B_vals[i]!=0)
			upd_led_B_vals[i]--;				
	}
	// <<<<< Decrease RGB update values
	
	// >>>>> Update LED status
	// <<<<< Update LED status
	
	// Update cycle index
	led_upd_count++;
}
